<?php

namespace application\protect;

class protectPassword{

    static public function passwordHash($password){

      return password_hash($password,PASSWORD_BCRYPT);
    }

    static public function passwordCheck($password, $hash) {
       return password_verify($password, $hash);
    }
}
// статья на Хабре про засолку паролей http://surl.li/lgpt
//about password_hash https://habr.com/ru/post/194972/
// про функции хеширования http://surl.li/lgqb

/* $password = md5($password . "MyUniqueSault"); Использование
 статической соли небезопасно
Хакер украдет нашу бд и сможет сделать обратное действие за 5 сек

Для устранения этого минуса используется уникальная соль к каждому хешу:
       $sault = GenerateRandomString();
       $password = md5($password . $sault); */
/* 
       1. Нет соли — используем уже готовые радужные таблицы.
2. Есть одна на всех соль — генерируем одну радужную таблицу 
и «ломаем» по ней всех пользователей.
3. Есть отдельная соль для каждого пользователя
 — отдельно брутфорсим каждого пользователя.
 Если украдут БД нас все равно взломают .((
     Речь в этих статьях о противостоянии брутфорсу, 
     который победить нельзя, но можно выиграть время.
     
butteredcat
27 июля 2010 в 17:00

+2
salt есть вещь хорошая, но ее используют для того, чтобы 
у пользователей с одинаковыми паролями были не одинаковые
 хеши. а с точки зрения brute-force для хеш-функций одной разрядности,
 мягко говоря, «пофиг» на изменение выходной строки.
 
homm
27 июля 2010 в 18:40

+2
Солью называют любую строку, добавляемую к паролю перед передачей
 в шех-функцию. Это не обязательно ник,
 как, судя по всему, полагаете вы. Эта соль призвана 
 предотвратить поиск пароля по словарю посчитанных хешей.
  Соль изменяет результат хеш функции, следовательно
   словарь для функции без соли не подойдет, нужен другой словарь.
    Но таких словарей просто не существует, потомучто вариантов
     просаливания паролей бесчетное множество. Следовательно,
      соль защищает от подбора по словарю.

А защитой от совпадения хешей у пользователей с 
разными паролями является использование в качестве 
компонента соли логина, или другой информации и пользователе.
 */


   /*    Поддерживаемые опции для PASSWORD_BCRYPT:

salt (string) - для самостоятельного задания соли для хеширования. 
Обратите внимание, 
что это приведёт к переопределению и предотвращению
 автоматического создания соли.

Если не задано, то password_hash() 
будет генерировать случайную соль для каждого хешируемого пароля. 
Предостережение
Настоятельно рекомендуется использовать автоматическую генерацию соли. Данная функция самостоятельно создаст хорошую соль, если вы не будете ей мешать подсовывая свою.

Как было замечено выше, опция salt была объявлена устаревшей в PHP 7.0 и будет 
вызывать соответствующее предупреждение.
 Поддержка ручного задания соли может быть удалена в более новых версиях.
Это предпочтительный режим работы. 
Возвращает хешированный пароль или false в случае возникновения ошибки.
*/
/*       Почему популярные хеширующие функции, такие как md5() и sha1() не 
      подходят для паролей?
Такие хеширующие алгоритмы как MD5, SHA1 и SHA256 были спроектированы
 очень быстрыми и эффективными. При наличии современных технологий и 
 оборудования, 
стало довольно просто выяснить результат этих алгоритмов методом 
"грубой силы" для определения оригинальных вводимых данных.

Из-за той скорости, с которой современные компьютеры могут 
"обратить" эти хеширующие алгоритмы, многие
 профессионалы компьютерной безопасности строго
  не рекомендуют использовать их для хеширования паролей. */



        
    